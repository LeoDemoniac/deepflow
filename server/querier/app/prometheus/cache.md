# PromQL 查询 cache 机制

此文档说明 PromQL 查询内的缓存工作机制。

## 相关参数及说明

```yaml
querier:
  prometheus:
    operator-offloading: # 控制是否开启 offloading query
    cache:
      remote-read-cache: # 是否开启 remote read cache
      response-cache: # 是否开启 reponse cache
      cache-item-size: # 限制每个 cache 项的大小
      cache-max-count: # 限制总共允许存在多少个 cache 项，初始化为 cache lru 的大小
      cache-first-timeout: # 初次查询一个表达式时的等待时长
      cache-clean-interval: # cache 清理间隔
      cache-allow-time-gap: # 允许 cache 不更新的时间间隔
```

## 机制

在说明这些参数具体作用之前，先说明基本的工作流程：

每一个缓存项的数据结构如下，缓存列表初始化大小由 [cache-max-count] 控制。

```
┌───────────┐
│ ┌───────┐ │
│ │       │ │
│ │ start │ │
│ │       │ │
│ │ end   │ │
│ │       │ │
│ │ data  │ │
│ │       │ │
│ └───────┘ │
│           │
│  .......  │
└───────────┘
```

### 缓存获取

注：[ ] 表示缓存范围，{{ }} 表示查询范围，/// 表示缓存命中d，::: 表示未命中，需要查询补充部分

```
                         1. 没有此 Key
                        ┌────────► [发生查询]，创建一个新缓存块并把缓存数据标记为无效（被 [3. 无效数据] 等待） ──────► 查询结束后替换无效数据块，并通知等待结束(close Channel)
                        |
                        │                 2.1 完全命中（查询时间在缓存时间段内）[  {////}  ]
                        │                ┌───────────► 直接返回命中数据块，没有查询
                        │                │                                          ┌──────────────► 缓存开始范围与查询结束范围有交集，返回 [查询开始时间，缓存开始时间] 作为查询时间，[发生查询]，查询结束后进行缓存合并
                        │                │                                          │  2.2.1 头交集 {{:::[///}}  ]
                        │                │                                          │
                    2. 有效数据           │            2.2 部分命中                   │      2.2.2 中间交集 {:::[///]:::}
请求 ─► 查找 Key ──────────► 通过时间交集判断命中范围 ───────────────► 判断部分命中的交集 ─────────────► 等价于 2.3 完全不命中，返回查询时间进行查询，[发生查询]，查询结束后替换整个缓存块
                        │                │                                          │
                        │                │                                          │
                        │                │                                          │  2.2.3 尾交集 [  {{///]:::}}
                        │                │                                          └──────────────► 缓存结束范围与查询开始范围有交集，判断时间容忍 [cache-allow-time-gap]，在容忍期不更新，否则返回 [缓存结束时间，查询结束时间] 作为查询时间，[发生查询]，查询结束后进行缓存合并
                        │                │  2.3. 完全不命（查询时间与缓存时间无交集）
                        │                └─────────────────► 等于无缓存，不创建新缓存块，[发生查询]，查询后替换掉缓存块
                        │
                        │ 3. 无效数据：找到 Key，但数据标记为无效(时间为0或数据类型为 None)
                        └───────────────► 说明某个线程正在请求同一个 Key，进入等待，此等待默认 10s，对应配置 [cache-first-timeout]，当 Channel 被关闭后，等待会强行结束（也就是 Channel 不会收到数据），然后尝试获取数据，然后进入 [2.有效数据] 流程，若超时则直接返回异常
```

注：其中，对于[发生查询]：如果查询正常结束，则会替换或补充缓存数据；如果查询异常结束有错误且数据块为[无效数据]，则会清理掉 Key，这是防止发生未知异常导致退出，如果 Key 一直占用且标识为无效数据，后来所有同一个 Key 的请求都会走 [1.无效数据] 流程等待 10s 直到超时

### 缓存合并

缓存的每一项的结构示例如下，其中，当且仅当所有 key:value 的数量、值都完全一致才允许合并

```
┌────────────────────────────────┐
│                                │
│ ┌───────────────────┐          │
│ │ key: value(string)│ []labels │
│ └───────────────────┘          │
│                                │
│ ┌───────┐ ┌───────┐            │
│ │ time1 │ │ time2 │ []samples  │
│ │ value │ │ value │            │
│ └───────┘ └───────┘            │
│                                │
└────────────────────────────────┘
```

上述缓存获取过程中，当发生【头交集】与【尾交集】时，需要做缓存合并，即将查询到的数据补充到缓存数据中。合并过程为：

```
                      ┌──────► 头交集 ─────────► 找到新数据的时间点 >= 缓存数据的第一个样本时间点的索引，将新数据的[0:目标索引]数据拷贝到缓存数据之前
                      │     {{:::[///}}  ] -> 找到 '[' 的位置，把 ::: 补充到缓存中
                      │
以新数据为外层            两个操作都需要判断时序是否相等
以缓存数据为内层做遍历 ─── 当没有查询到新数据时，直接跳过遍历，此时需要更新缓存块的时间，标识**新的查询时间段内没有数据**，避免重复查询
                      │
                      │
                      │     [  {{///]:::}} -> 找到 ']' 的位置，把 ::: 补充到缓存中
                      └──────► 尾交集 ─────────► 找到新数据的时间点 > 缓存数据的最后一个样本时间点的索引，将新数据的[目标索引:len-1]数据拷贝到缓存数据之后
```

### 缓存清理

由 [cache-clean-interval] 参数控制清理时间，在每个间隔触发时，遍历缓存项获取每项大小，当占用内存大小超出 [cache-item-size] 大小时，移除该缓存数据。

## 差异

目前缓存有两种，一种通过 [remote-read-cache] 开关，一种通过 [response-cache] 开关，在说明这二者差异之前，需要说明 PromQL 查询的处理机制：

```
                                                  ┌──────► A 原始查询: [向量查询] 转化为 Querier SQL -> 查询原始数据集 ──────────────────>
                                                  │                                  `remote-read-cache` 位置
                                                  │
PromQL 请求 -> 解析表达式 -> 表达式被拆分为多个向量查询───                                                       Prometheus Engine 二次处理得到最终结果集
                                                  │                                                                `response-cache` 位置
                                                  │
                                                  │
                                                  └──────► B 卸载计算: [向量查询] 转化为 Offload Querier SQL -> 查询原始数据集 ──────────>
```

也即 `remote-read-cache` 是对数据库结果的缓存，`response-cache` 是对最终结果的缓存。

在 A 与 B 两个过程里，A 仅仅是转换核心的时序，而 B 会转换外层的查询函数，比如对于表达式：`sum(node_cpu_seconds_total) by (cpu)`：
- A 转换为：`select value from node_cpu_seconds_total`
- B 转换为：`select sum(value) from node_cpu_seconds_total grop by cpu`，是否转换这种类型的查询通过 [operator-offloading] 开关控制

在最开始，PromQL 的查询层只有 A 查询转换，但是实际环境存在形如 `rate(node_cpu_seconds_total[1d])` 类型的查询，会一次性加载 1d 的数据到内存中，显然这是不合理的。所以提出了一个优化方案：将 rate 函数放在 Clickhouse 中计算，也就不用从 Clickhouse 加载 7d 数据到 Server 中，最后需要的仅仅是查询范围内的数据量，实现为 B 类型查询。

但这样 `remote-read-cache` 缓存就产生了一些问题：

1. `remote-read-cache` 设计是对同一个时序可复用的，比如 `sum(node_cpu_seconds_total) by (cpu)` 与 `avg(node_cpu_seconds_total) by (cpu)` 、`max(node_cpu_seconds_total) by (cpu)` 共享一个 cache，而对 B 类型的查询，共用一个 `remote-read-cache` 是错的，因为在 Clickhouse 层两个查询经过了不同的函数计算。

2. 对 Instant Query（瞬时查询）而言，A 查询做缓存是有效的，但是 B 查询做缓存不一定有效。Instant Query 的默认扫描范围是 5min，在 `remote-read-cache` 下：
- A 查询缓存的是 `node_cpu_seconds_total` 5min 内的原始数据，查询任意时间点只需要获取查询时间最近的一个数据样本即可；
- B 查询缓存的是 `sum(node_cpu_seconds_total) by (cpu)` 在 5min 最后一个时间点的值，由于存在**扫描时差**的问题，直接读取缓存数据不一定准确；

对于扫描时差，可以这样理解，如下示例图，在 T2 时间点求 sum，这 4 个时序最接近 T2 的值做求和，期望得到的结果是 `1+2+3+4`。类比在 T1 时间点，期望得到是 `1+2`。对于两种查询而言，如果缓存的是 [0,T2] 的数据：
- A 查询：缓存的是原始数据集，在具体的查询时间点获取原始值即可，不符合时间点的数据将被抛弃，计算正确。
- B 查询：缓存的是 sum 结果，T2 得到的结果正确，但不存在 T1 的缓存结果，会认为没有数据，需要重新查询一次 T1 才是正确的。

```
Series
  ▲
  │      │ T1       │ T2
  │      │          │
  │      │    ┌───┐ │
  │      │    └───┘4│
  │      │          │
  │      │ ┌────┐   │
  │      │ └────┘3  │
  │      │          │
  │     ┌│──┐       │
  │     └│──┘2      │
  │  ┌───┤─┐        │
  │  └───┤─┘1       │
  │      │          │
──┼──────┤──────────┼─────► Time
```

3. 对于区间向量聚合，求值范围不同，如这个表达式：`sum_over_time(node_cpu_seconds_total[5m])` 在 `remote-read-cache` 下：
- A 查询直接获取原始数据集，Prometheus Engine 在指定时间范围内求和；
- B 查询的原始数据集是 00:05 的数据，比如 00:05 的 sum 是 [00:00-00:05] 的和，00:06 的 sum 是 [00:01-00:06] 的和，需要剔除 00:00-00:01 的值

有两个方法可以解决：
1. 将 `remote-read-cache` 改造为同时兼容 A B 两种查询，不同的函数计算分别独立缓存结果，缺点是 A 查询的缓存会有很多重复数据与多余的内存占用。
2. 新增 `response-cache`，直接缓存 B 查询结果，由于这种实现会使得缓存的时序数量大量增加，而通常而言响应结果的大小会比数据库结果少很多，综合考虑直接缓存响应结果，避免缓存数据占用内存过大，缺点是增加维护负担。

目前采用了方法2，这就是 [remote-read-cache] 开关与 [response-cache] 开关的差异。
